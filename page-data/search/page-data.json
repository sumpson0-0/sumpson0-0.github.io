{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\nCORS에 대해 알기 위해서는 동일 출처 정책(SOP)을 알고 넘어가야 한다.  \r\n이게 뭔가 싶어도 조금만 더 글을 읽어보자.\r\n\r\n# 동일 출처 정책(SOP)과 CORS\r\n\r\n<br />\r\n\r\n\r\n우리가 `<script>`내에서 보내는 HTTP 요청(XMLHttpRequest와 Fetch API 등)은 **서로의 출처가 동일한 경우에만 리소스 공유를 허용하는 정책**을 따른다. \r\n\r\n이를 **동일 출처 정책(Same-Origin-Policy)**이라고 부르는데, 이 정책을 따름으로써 잠재적으로 해로울 수 있는 문서를 분리하여 공격받을 수 있는 경로를 줄일 수 있게 되는 것이다.\r\n\r\n<br />\r\n\r\n\r\n여기서 말하는 **동일한 출처**란, **두 URL의 프로토콜, 호스트, 포트**(명시한 경우)**가 모두 같은 경우**를 말한다.\r\n\r\n아래의 예시를 통해 동일 출처 여부를 판별해보자.\r\n\r\n| URL | 성공/실패 | 설명          |\r\n| --------| -------| --------------|\r\n| <span style=\"color:blue\">http://store.company.com</span>/dir2/other.html| 성공      |  경로만 다름 |\r\n| <span style=\"color:blue\">http://store.company.com</span>/dir/inner/another.html  | 성공     |  경로만 다름 |\r\n|  <span style=\"color:red\">https</span>://store.company.com/secure.html   | 실패      | 프로토콜 다름|\r\n| http://<span style=\"color:red\">news.company.com</span> /dir/other.html | 실패     |호스트다름 |\r\n| http://store.company.com:<span style=\"color:red\">81</span>/dir/etc.html  | 실패     |포트 다름 (80이 기본) |\r\n\r\n그렇다면 **다른 출처의 리소스를 가져올 수 있는 방법**은 없을까?\r\n\r\n<br/>\r\n\r\n웹에서는 동일 출처 정책을 우선시하지만 **출처가 달라도 특정 조항을 지켰을 경우 리소스 공유가 가능**하도록 하는데, 그중 하나가 바로 **CORS**다. \r\n\r\n즉, **동일 출처 정책을 벗어난 URL에서 리소스 공유를 요청해도 CORS 정책을 지킨 응답을 반환받기만 한다면 리소스 공유가 가능**하다는 것이다.\r\n\r\n<br />\r\n\r\n# CORS 정책을 지킨 응답을 얻는 방법\r\n\r\n<br />\r\n\r\n프론트엔드 단에서 개발을 하다 보면 한 번쯤 마주하게 되는 다음의 에러(🤦🏻‍♀️)는 두 URL의 출처가 다른 상태에서 CORS 정책까지 위반했을 경우 나타나는 것이다. \r\n\r\n> 🚨<span style=\"color:red\">Access to XMLHttpRequest at 'Request URL' from origin 'Origin' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</span> 🚨\r\n\r\n<br />\r\n\r\n이제 이 **지긋지긋한 CORS 에러와 이별할 수 있는 방법**을 알아보자.🤚🏻🤚🏻\r\n\r\n<br />\r\n\r\n## 서버에서 해결하는 방법(근본적인 해결책)\r\n\r\n<br />\r\n\r\n### 1. 서버측에서 응답 헤더에 'Access-Control-Allow-Origin'을 설정한다.\r\n\r\n서버는 ‘Access-Control-Allow-Origin’에 허용할 출처(origin)를 입력하고 이를 응답 헤더에 넣음으로써 CORS 정책을 허용할 수 있도록 한다.\r\n\r\n **‘Access-Control-Allow-Origin’**은 **CORS 정책에 허용할 출처를 명시하는 헤더**이다. 리소스 접근을 허용할 특정 출처를 입력하거나 (*)를 사용하여 모든 출처를 허용할 수 있다. \r\n\r\n이후 서버에서 ‘Access-Control-Allow-Origin’를 담은 응답 헤더를 브라우저로 반환하면, 브라우저는 응답 헤더에 있는 ‘Access-Control-Allow-Origin’과 자신이 요청 시 보냈던 'Origin'을 비교해 이 응답이 유효한지 판별한다. 유효하다고 판별했을 경우 CORS 에러 없이 성공적으로 리소스를 공유 받을 수 있다. \r\n\r\n여기서 우리는 **CORS 정책의 위반 여부를 판단하는 것은 서버가 아닌 브라우저**라는 중요한 사실을 알 수 있다.\r\n\r\n백엔드 개발자와 작업을 하는 경우라면  ‘Access-Control-Allow-Origin’ 설정을 요청하면 되지만, 제공되는 API를 사용하여 개발하는 (본인 같은) 경우에는 서버 측에 '내 Origin도 Access-Control-Allow-Origin에 넣어주세요.' 할 수 없어 당장 사용할 수 없는 방법이었다.😅\r\n\r\n<br/>\r\n\r\n## 프론트엔드에서 해결하는 방법\r\n\r\n사실상 프론트엔드 개발자들이 CORS 에러를 가장 많이 마주할 것이라고 생각한다. (실제로도 그렇다고.)  그렇다면 서버 측에 직접 요청이 불가할 불가할 경우 (본인 포함) 프론트엔드 측에서 쓸 수 있는 해결책에는 어떤 것들이 있을까.\r\n\r\n<br/>\r\n\r\n### 1. 외부 요청을 가능하게 해주는 플러그인 설치.\r\n\r\n<br/>\r\n\r\n**크롬**의 경우 응답 헤더에  **Access-Control-Allow-Origin' : * 를 설정해 주는 확장 프로그램이 존재**한다. 이를 설치하여 사용하면 해당 플러그인이 설치된 크롬 브라우저에 한해서 CORS 에러 없이 리소스를 공유 받을 수 있다.\r\n\r\n\r\n구글에 CORS 플러그인을 치면 다양한 것들이 나오니 원하는 것으로 사용하자.\r\n\r\n(본인은 Moesif CORS를 사용해본 경험이 있다.)\r\n\r\n<br/>\r\n\r\n**문제점**\r\n\r\n- 해당 플러그인이 설치된 크롬 브라우저에 한해서만 리소스 공유 가능한 **임시 방편**이다.\r\n\r\n<br/>\r\n\r\n### 2. Proxy 설정\r\n\r\n<br/>\r\n\r\nProxy는 '대리'라는 의미를 가지고 있는데, 여기서 Proxy는 클라이언트와 백엔드 서버의 중간 다리 역할을 한다.\r\n클라이언트 입장에서 Proxy는 원격 서버처럼 동작하고, 백엔드 서버 입장에서 Proxy는 클라이언트처럼 동작한다고 인식하게 된다. \r\n\r\n<br/>\r\n\r\n이전에는 클라이언트 측에서 백엔드 서버 측에 직접적으로 리소스 공유를 요청했다면, Proxy 설정 시 클라이언트에서 Proxy 서버를 통해 백엔드 서버로 요청을 보내게 된다. 이후 서버에서 다시 Proxy 서버를 거쳐 브라우저로 응답을 반환한다. **CORS 정책을 우회하여 리소스를 공유 받을 수 있는 것**이다.\r\n\r\n![](screenshot.gif)\r\n출처 : [https://en.wikipedia.org/wiki/Proxy_server](https://en.wikipedia.org/wiki/Proxy_server) \r\n\r\n<br/>\r\n\r\n기본적으로 **Proxy를 설정하는 방법**은 **Webpack Dev Server 혹은 http-proxy-middleware를 사용**하는 것이다. (Webpack Dev Server 역시 내부적으로 http-proxy-middleware를 사용하여 백엔드 서버에 Proxy 한다고 하니, 둘 중 무엇을 사용해도 무방해 보인다.)\r\n\r\n<br/>\r\n\r\n\r\n두 가지 모두 매뉴얼에 방법이 잘 나와 있기에 부족한 설명 대신 링크를 첨부한다.\r\n\r\n📎[Webpack Dev Server](https://webpack.js.org/configuration/dev-server/)\r\n📎[http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware#options)\r\n\r\n<br/>\r\n\r\n**CRA(Create-React-App)를 이용해 만든 프로젝트의 경우**에는 **package.json에 \"proxy\"를 입력만 하면 간편하게 설정이 가능**하니 이를 활용하자. \r\n\r\n본인의 경우 CRA를 통해 프로젝트를 생성했기 때문에 package.json으로 설정을 진행했다.  \r\n (📎[create-react-app proxying](https://create-react-app.dev/docs/proxying-api-requests-in-development/))\r\n\r\n\r\n<br/>\r\n\r\n예) api url이 http://localhost:3000/api/recommend\"인 경우 CRA Proxy 설정법\r\n```javascript\r\n// package.json\r\n\"proxy\": \"http://localhost:3000\" //1. proxy에 Origin 입력\r\n\r\n// api.js\r\nfetch(/api/recommend); //2. url에서 Origin을 제외한 나머지 주소를 입력하여 요청\r\n```\r\n\r\n<br/>\r\n\r\n**문제점**\r\n\r\n- 중간단계가 있기 때문에 속도가 느려지는 단점이 있다.\r\n- 로컬 개발 환경에서만 적용이 가능하다.\r\n\r\n<br/>\r\n\r\n**내가 직면한 문제**\r\n\r\n로컬 환경에서 Proxy를 설정했을 때는 문제없이 작동하던 웹이, AWS S3로 배포를 진행하자 또다시 CORS 에러를 송출(🤦🏻‍♀️)하는 상황이 발생했다. \r\n\r\n<br/>\r\n\r\n무엇이 문제였을까?\r\n\r\n<br/>\r\n\r\nProxy를 통해 설정한 것은 개발 서버이기 때문에 배포 대상이 되는 환경에서는 사용할 수 없다. 배포 시 build를 하게 되면 단순 static 파일로 변환이 되기 때문이다.\r\n\r\n<br/>\r\n\r\n이를 해결하기 위해서는 배포할 서버에 별도로 웹서버를 구성해야 하고 필요에 따라서 Proxy 설정도 추가해 줘야 한다.\r\n\r\n(여기서 막히는 바람에 1차 실패..🤦🏻‍♀️)\r\n\r\n<br/>\r\n\r\n### 3. 서버를 구축하여 서버간 통신으로 외부 API에 데이터 요청\r\n\r\n<br/>\r\n\r\n본인의 경우 로컬 환경에서 개발한 프로젝트를 포트폴리오 용으로 사용해야 했기 때문에 가급적이면 배포를 하고 싶었다. 그런데 위에서 언급한 대로 build된 환경에서는 proxy를 사용할 수 없어 또다시 CORS 에러를 보게 된 상황에 놓인 것이다.\r\n\r\n<br/>\r\n\r\n여기서 배포를 포기해야 하나 싶었지만 어딘가 돌파구가 있지 않겠냐는 마음으로 구글링을 하고 (또 하고..) 또 해서 서버에서 외부 API로 요청하는 방법이 있다는 사실을 알게 되었다.\r\n\r\n<br/>\r\n\r\n클라이언트-서버 간의 통신은 브라우저에서 CORS 정책을 확인하지만, 서버 간 통신은 브라우저가 개입하지 않는다. 즉, CORS 정책에 영향을 받지 않고 데이터를 받아올 수 있다.\r\n\r\n<br/>\r\n\r\n**백엔드 서버를 구축하여 서버 간 통신으로 리소스 공유를 받은 다음, 백엔드 서버의 응답 헤더에 'Access-Control-Allow-Origin'을 직접 설정한다. 그리고 클라이언트 측에서 백엔드 서버로 데이터를 요청하면 리소스를 공유 받을 수 있다.**\r\n\r\n<br/>\r\n\r\n\r\n(현재 서버를 구축하는 방법으로 CORS 해결을 시도하는 단계에 있다.🏃🏻‍♀️)\r\n\r\n<br/>\r\n\r\n# 글을 마치며\r\n\r\n최근 프로젝트에서뿐 아니라 프론트엔드 개발을 시작하고 얼마 지나지 않았을 때부터 CORS 에러를 계속 봐왔다. 처음 CORS 에러에 직면했을 때는 개발을 시작한 지 얼마 지나지 않은 상태였기에 얼마나 당황스러웠는지 모른다. 당시 처음부터 CORS의 개념을 짚어가기엔 개발에 대한 지식이 많이 부족했기에 (지금도 부족하지만) 엄두가 나지 않아 우회할 수 있는 방법을 우선적으로 찾았던 것 같다.\r\n\r\n<br/>\r\n\r\n시간이 지나 처음보다 개발에 대한 시야가 넓어지게 되면서 CORS에 대해서 제대로 알아보고 싶다는 생각이 들어 이렇게 짚어보게 되었다. 아직 전부를 안다고 할 수는 없지만 CORS가 어떤 것이고 왜 이런 문제가 발생했는지 이해할 수 있어 유익한 시간이었다.\r\n\r\n<br/>\r\n\r\n지금 공부한 내용이 앞으로의 개발에 조금이나마 도움이 되길 바라며 글을 마친다.\r\n\r\n<br/>\r\n\r\n---\r\n## 참조\r\n\r\n[동일 출처 정책 - MDN](https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy)\r\n\r\n[교차 출처 리소스 공유(CORS)- MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)\r\n\r\n[CORS 와 Webpack DevServer Proxy](https://react.vlpt.us/redux-middleware/09-cors-and-proxy.html)\r\n\r\n[CORS는 왜 이렇게 우리를 힘들게 하는걸까?](https://evan-moon.github.io/2020/05/21/about-cors/)","excerpt":"CORS에 대해 알기 위해서는 동일 출처 정책(SOP)을 알고 넘어가야 한다. 이게 뭔가 싶어도 조금만 더 글을 읽어보자. 동일 출처 정책(SOP)과 CORS 우리가 내에서 보내는 HTTP 요청(XMLHttpRequest와 Fetch API 등)은 …","fields":{"slug":"/algorithm-permutation-prime copy/"},"frontmatter":{"date":"Feb 25, 2021","title":"CORS 에러와 이별하기","tags":["Error","CORS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"프로그래머스 코딩 테스트 [완전 탐색 : 소수 찾기] 문제를 풀며 공부한 내용을 정리한 글이다.\r\n\r\n[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/42839)\r\n\r\n## 문제 요약\r\n\r\n주어진 numbers를 가지고 만들 수 있는 모든 조합 중, 소수에 해당하는 조합의 개수를 return하는 solution 함수를 작성하시오.\r\n\r\n| numbers | return | 설명                                                           |\r\n| --------| -------| --------------                                                 |\r\n| \"17\"    | 3      | [1, 7]으로는 소수 [7, 17, 71]을 만들 수 있으므로 3을 return한다.  |\r\n| \"011\"   | 2      | [0, 1, 1]으로는 소수 [11, 101]을 만들 수 있으므로 2를 return한다. |\r\n\r\n\r\n## 최종 작성 코드\r\n```javascript\r\nfunction solution(numbers) {\r\n    var answer = new Set(); \r\n    let nums = numbers.split(''); \r\n    \r\n    const isPrimeNum = (num) => {\r\n         if (num <= 1) return false;\r\n         if (num === 2) return true;\r\n         for (let i = 2; i <= Math.sqrt(num); i++) {\r\n              if (num % i === 0) return false;\r\n         }\r\n         return true;\r\n    }\r\n    \r\n    const getPermutation = (arr, fixed) => {\r\n        if(arr.length >= 1) {\r\n            for (let i=0; i<arr.length; i++) {\r\n                const newFixed = fixed + arr[i]; \r\n                const copyArr = arr.slice();\r\n                copyArr.splice(i, 1); \r\n                \r\n                if (!answer.has(parseInt(newFixed)) && isPrimeNum(parseInt(newFixed))){\r\n                    answer.add(parseInt(newFixed)) \r\n                }\r\n                \r\n                getPermutation(copyArr, newFixed); \r\n            }\r\n        }\r\n    }\r\n    \r\n    getPermutation(nums, '');\r\n     \r\n    return answer.size;\r\n}\r\n```\r\n# 키포인트\r\n<br>위 코드에서 중요하게 생각한 포인트는 다음과 같다.\r\n\r\n\r\n1. 완전 탐색으로 모든 조합 구하기.\r\n2. 소수 찾기 알고리즘으로 소수 판별하기.\r\n3. 중복되는 조합 걸러내기.\r\n\r\n\r\n## 1. 완전 탐색으로 모든 조합 구하기.\r\n\r\n<br>**완전 탐색**\r\n> 전체 요소를 일일이 순회하여 가능한 모든 경우의 수를 도출하는 것\r\n\r\n<br>\r\n말 그대로 모든 요소들을 하나하나 확인해 가능한 조합들을 전부 찾아내는 방법이다. \r\n<br>완전 탐색을 수행할 수 있는 방법으로는 브루트 포스, 비트 마스트, 백 트래킹, 순열 등 여러 가지가 있는데, 여기서는 재귀 함수를 통해 순열을 구하는 것으로 문제를 해결하였다.\r\n\r\n<br><br>**어떻게 순열로 완전 탐색을 수행할 수 있을까?**\r\n\r\n<br>**순열의 원리**를 이미지로 살펴보면 다음과 같다.\r\n\r\n![](screenshot.gif)\r\n[출처 : https://www.geeksforgeeks.org/wp-content/uploads/NewPermutation.gif]\r\n\r\n<br>A와 A를 스왑한다. 스왑된 A는 고정(fixed)되며, A가 고정된 상태에서 나머지 B, C 역시 A와 같은 과정을 거친다. B와 B가 스왑되면, 고정된 AB를 제외하고 C만 남기 때문에 [A, B, C]가 AB를 고정했을 때 만들 수 있는 조합이 된다. 다음으로 B와 C를 스왑해 AC를 고정시키면 C만 남기 때문에 [A, C, B]가 AC를 고정했을 때 만들 수 있는 조합이 된다. 그리고 이 두 가지 조합이 A를 고정했을 때 만들 수 있는 조합이 되는 것이다. 이 과정을 A와 B가 스왑 될 때, A와 C가 스왑될 때 역시 동일하게 진행하면 그림과 같이 총 여섯 가지의 조합을 얻을 수 있다. (제시된 문제에서는 자리 수와 상관없이 모든 조합을 구해야 하지만 원리는 이와 동일하다.)\r\n\r\n\r\n<br>위 내용을 토대로 [\"0\", \"1\", \"1\"]의 순열을 구하여 result에 push하는 코드를 작성해보았다.\r\n\r\n```javascript\r\nconst arr = [\"0\", \"1\", \"1\"];\r\nlet result = [];\r\n\r\nconst getPermutation = (arr, fixed) => {\r\n        if(arr.length >= 1) {\r\n            for (let i=0; i<arr.length; i++) {\r\n                const newFixed = fixed + arr[i];\r\n                const copyArr = arr.slice();\r\n                copyArr.splice(i, 1);\r\n\r\n                result.push(newFixed);\r\n\r\n                getPermutation(copyArr, newFixed);\r\n            }\r\n        }\r\n    }\r\n\r\ngetPermutation(arr, '')\r\n\r\nconsole.log(result);\r\n// [\"0\", \"01\", \"011\", \"01\", \"011\", \"1\", \"10\", \"101\", \"11\", \"110\", \"1\", \"10\", \"101\", \"11\" ,\"110\"]\r\n```\r\n\r\n**코드 설명**  \r\n<br>순열을 얻을 수 있는 getPermutation 함수에 요소가 담긴 배열과 비어있는 String을 인자로 제공하여 호출한다. (아직 고정 값이 없기 때문에 빈 String 제공)  \r\n제공된 String과 배열의 i번째 요소(arr[i])를 합쳐 새로운 고정 값(newFixed)으로 지정하고, 고정된 요소(arr[i])를 splice로 배열에서 제거하여 고정되지 않은 요소들로 copyArr를 구성한다.   \r\ncopyArr와 newFixed를 getPermutation의 인자로 제공해 재귀 함수를 호출하면, 전달받은 arr에 요소가 1개 이상이기 때문에 코드가 실행되고, fixed로 제공된 값에 배열의 i번째 요소(arr[i])를 붙여 newFixed로 만든 후, 붙인 요소를 배열에서 제거한다. 이후 해당 배열과 newFixed를 다시 getPermutation의 인자로 주어 재귀 함수를 호출한다. 모든 요소가 fixed 되어 arr로 전달되는 요소가 없어질 때까지 재귀 함수가 호출되며, 탐색이 끝나면 모든 조합이 도출된다.\r\n\r\n## 2. 소수 찾기 알고리즘으로 소수 판별하기.\r\n**소수**\r\n> 1과 자기 자신으로만 나누어 떨어지는 1보다 큰 양의 정수.  \r\n(1과 자기 자신으로만 떨어진다 = 약수가 두 개 뿐이다)  \r\n<br>예) 19의 약수는 [1, 19] 이므로, 19는 소수이다.\r\n\r\n<br>\r\n\r\n**약수**\r\n> 나눴을 때 나머지가 0이 되는 수.  \r\n<br>예) 9의 약수는 [1, 3, 9] 이므로, 9는 소수가 아니다.\r\n\r\n<br>위의 정의를 그대로 적용하면 소수 여부를 판별하는 방법은 어렵지 않다.   \r\n판별하고자 하는 수를 2부터 자신보다 작은 수로 전부 나눴을 때 약수가 하나라도 나오면 소수가 아니라는 뜻이니 말이다.\r\n\r\n<br>이를 코드로 작성해보면 다음과 같다.\r\n\r\n```javascript\r\nconst isPrimeNum = (num) => {\r\n     if (num <= 1) return false;\r\n     if (num === 2) return true;\r\n     for (let i = 2; i < num; i++) {\r\n          if (num % i === 0) return false;\r\n     } \r\n     return true;\r\n}\r\n```\r\n\r\n위 과정은 당연하게 소수 여부를 판별할 수 있지만, 2부터 자신 보다 작은 수까지 전부 탐색 해야 한다는 단점을 가지고 있다. 예를 들어, num이 9일 경우 코드상으로 2부터 8까지 모든 수를 순회해야만 9가 소수가 아니라는 결론을 얻을 수 있지만, 실제론 3으로 나누는 시점이 결론이 도출되는 분기점이 되기 때문에 4에서 8까지의 탐색은 불필요하다는 것을 알 수 있는 것이다.\r\n\r\n<br>그렇다면 모든 수를 순회하지 않도록 **과정을 최소화**할 수 있는 방법은 무엇일까?  \r\n\r\n<br>2부터 자신의 양의 제곱근 이하의 수까지 나누어 소수 여부를 판별할 수 있는 **소수판별법**을 사용하면 불필요한 과정을 단축 시킬 수 있다. 9의 경우 양의 제곱근인 3까지, 25의 경우 양의 제곱근인 5까지 자신을 나눴을 때 0으로 떨어지면 소수가 아니고, 떨어지지 않으면 소수가 되는 것이다.  \r\n(소수 판별법에 대한 자세한 설명은 아래 링크를 참조하길 바란다.)\r\n\r\n[소수 판별볍 - 위키백과](https://ko.wikipedia.org/wiki/%EC%86%8C%EC%88%98%ED%8C%90%EB%B3%84%EB%B2%95)\r\n\r\n\r\n<br>JavaScript에는 양의 제곱근을 구하는 `Math.sqrt()` 메서드가 있으므로, 이를 이용해 for문이 순회할 범위를 좁혀주면 다음과 같은 코드가 완성된다.\r\n\r\n```javascript\r\n const isPrimeNum = (num) => {\r\n     if (num <= 1) return false; // 소수는 1보다 큰 양의 정수입니다.\r\n     if (num === 2) return true; // 2는 짝수 중 유일하게 소수인 숫자입니다.\r\n     for (let i = 2; i <= Math.sqrt(num); i++) {\r\n          if (num % i === 0) return false;\r\n     }\r\n     return true; //위 과정들을 통과하면 true를 반환합니다.\r\n }\r\n```\r\n\r\n## 3. 중복되는 조합 걸러내기.\r\nJavaScript에는 `Set`이라는 메서드가 있는데,  \r\n<모던 JavaScript 튜토리얼>에서는 다음과 같이 `Set`의 정의를 게재하고 있다.\r\n\r\n**Set**\r\n> Set(셋)은 중복을 허용하지 않는 값을 모아 놓은 특별한 컬렉션입니다.\r\n\r\n<br>Set에 같은 값을 추가할 경우 최종적으로 하나의 값만 저장되기 때문에, 얻은 조합들을 `set.add()`로 추가하면 중복된 값을 추가로 저장하지 않도록 할 수 있다.\r\n\r\n여기에 `set.size`를 이용하면 앞서 Set에 저장한 값의 개수를 얻을 수 있다.\r\n\r\n<br>Set에 대한 자세한 설명이 필요하다면 아래 링크로 방문하길 추천한다.\r\n\r\n[모던 JavaScript - 맵과 셋](https://ko.javascript.info/map-set)\r\n\r\n<br>\r\n\r\n# 글을 마치며\r\n취업을 위해 코딩 테스트 문제를 풀며 알고리즘을 접하기 시작했는데, 이를 통해 알고리즘의 원리와 JavaScript의 메서드를 전보다 깊이 있게 알 수 있게 되어서 매우 다행이라는 생각이 들었다.\r\n\r\n향후에도 취업과 관계없이 알고리즘 문제를 꾸준히 풀어보면 좋을 것 같다는 생각이 들었고, 현재는 많이 부족하지만 꾸준히 문제를 풀어 알고리즘에 더욱 익숙해질 수 있도록 노력할 예정이다.\r\n\r\n---\r\n아울러 개발 블로그를 시작하면 좋을 것 같다는 생각을 막연하게 품고만 있던 찰나에 정리하고 싶은 내용이 생겨 이렇게 첫 글을 쓰게 되었습니다. 배워가는 입장에서 쓴 글이기에 문제점이 있을 수 있으니 이에 대하여 지적해 주는 분이 계시다면 열린 귀로 듣고 개선할 수 있도록 하겠습니다 :)","excerpt":"프로그래머스 코딩 테스트 완전 탐색 : 소수 찾기 문제를 풀며 공부한 내용을 정리한 글이다. 문제 링크 문제 요약 주어진 numbers를 가지고 만들 수 있는 모든 조합 중, 소수에 해당하는 조합의 개수를 return하는 solution 함수를 작성…","fields":{"slug":"/algorithm-permutation-prime/"},"frontmatter":{"date":"Feb 03, 2021","title":"[알고리즘] 완전 탐색 : 소수 찾기","tags":["Algorithm","프로그래머스"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}